 1)What is an Access Modifier?
      Access modifiers are keywords in C# that define the scope and visibility of classes, methods, variables, and other members. They control who can access them in your project

   Types:
       1. public
           --> No restriction.
           --> Accessible from anywhere (same class, other classes, other assemblies).

          EX:
                    public class Student
                     {
                        public string Name; // Accessible from anywhere
                     }

      2. private
         --> Most restrictive.
         --> Accessible only inside the same class.
         --> Default for class members (fields, methods).

              EX:
                 public class Student
                     {
                      private int age; // Only accessible inside Student class
                     }

      3.protected
           --> Accessible in the same class and in derived (child) classes.
           --> Not accessible outside if there is no inheritance.

              EX:
                  public class Person
                    {
                    protected string Address;
                    }

                   public class Student : Person
                  {
                     public void ShowAddress()
                        {
                         Console.WriteLine(Address); // OK, inherited class can access
                        }
                   }

        4. internal
             --> Accessible within the same assembly/project.
             --> Not accessible outside the assembly.
               EX:
                   internal class Teacher
                         {
                           internal void Teach()
                               {
                               Console.WriteLine("Teaching...");
                               }
                          }

        5.protected internal
                --> Combination of protected + internal.
                --> Accessible from child classes OR from the same assembly.
              EX: 
               public class Person
                  {
                    protected internal string Email;
                  }

      6. private protected (C# 7.2 and later)
             --> Combination of private + protected.
             --> Accessible only in the same assembly and only in derived classes.
             --> More restrictive than protected internal.
            EX:
              public class Person
              {
                private protected int Age;
              }

| Modifier           | Scope (Where it can be accessed)                                              | Use Case                                                                     |
| -------------------| ----------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| public             | Anywhere (same class, other classes, other assemblies)                        | For APIs, libraries, and methods meant to be used globally.                  |
| private            | Only inside the same class                                                    | For encapsulating internal details (e.g., fields, helper methods).           |
| protected          | Same class + child classes                                                    | For base class members that should be shared with derived classes.           |
| internal           | Anywhere inside the same assembly/project                                     | For code that is shared within a project but hidden from outside assemblies. |
| protected internal | Child classes (even in other assemblies) OR anywhere inside the same assembly | A mix of inheritance + internal sharing.                                     |
| private protected  | Child classes inside the **same assembly only** (introduced in C# 7.2)        | More restrictive than `protected internal`.                                  |

          🔹 Simple Summary (Easy to Remember)
            --> public → Everyone can see it.
            --> private → Only me (the class itself).
            --> protected → Me + my children (inheritance).
            --> internal → Only my family (same project/assembly).
            --> protected internal → My children (anywhere) OR my family (same assembly).
            --> private protected → My children but only if they live in the same house (same assembly).

🔹 Common Interview Questions on Access Modifiers
           ✅ Basic Questions
              1. What are access modifiers in C#?
              2. List all access modifiers available in C#.
              3. What is the default access modifier for a class? (Answer: internal)
              4. What is the default access modifier for class members? (Answer: private)

           ✅ Comparison Questions
              5. Difference between public and private.
              6. Difference between protected and internal.
              7. Difference between protected internal and private protected.
                       1)protected internal
                             Accessible by:
                                 Any class within the same assembly (internal)
                                  OR
                                Any derived (child) class in any assembly (protected)
                      Basically: Union of protected + internal

                       EX:
                           public class BaseClass
                              {
                                  protected internal int Value = 100;
                              }

                           public class Child : BaseClass
                              {
                                  public void Show()
                                  {
                                   Console.WriteLine(Value); // Accessible (inherited)
                                  }
                              }

                                 // In SAME assembly - also works without inheritance
                        public class Other
                              {
                                  public void Show()
                                     {
                                         BaseClass b = new BaseClass();
                                         Console.WriteLine(b.Value); // Accessible (same assembly)
                                     }
                              }

                     2.private protected
                           Introduced in C# 7.2
                                    Accessible by:
                                          Only derived (child) classes
                                           But within the same assembly only
                                 Basically: Intersection of protected + internal

                       ex:
                           public class BaseClass
                                {
                                     private protected int Value = 200;
                                 }

                                 public class Child : BaseClass
                                 {
                                     public void Show()
                                     {
                                         Console.WriteLine(Value); // Accessible (same assembly + inherited)
                                     }
                                 }
                                 
                                 // In SAME assembly but not a child
                                 public class Other
                                 {
                                     public void Show()
                                     {
                                         BaseClass b = new BaseClass();
                                         // Console.WriteLine(b.Value); ❌ Not Accessible
                                     }
                                 }



              8. Which access modifiers are allowed at class level? (Answer: public, internal)

          ✅ Scenario-based Questions
             9. If a class is marked internal, can it be accessed from another assembly? (Answer: No)
            10. Can a protected member be accessed without inheritance? (Answer: No)
            11. Which access modifier will you use for utility/helper methods inside a class? (Answer: private)
            12. Which access modifier will you use for framework/library classes meant to be reused by other projects? (Answer: public)

         ✅ Advanced Questions
             13. Why was private protected introduced in C# 7.2?
                            --> Before C# 7.2, we had protected internal, but it was too permissive.
                            --> Any class in the same assembly could access it (even if not derived).                               
                            --> Any child class in other assemblies could also access it.                                 
                            --> Developers wanted a stricter option:                                
                            --> Accessible only to derived classes                            
                            --> And only inside the same assembly.                 
                            --> So Microsoft introduced private protected in C# 7.2.

               👉 Short Interview Answer:
                           private protected was introduced to give developers finer control — it restricts access to only derived classes within the same assembly, 
                           unlike protected internal which is more open.
             14. Can a top-level class be declared private or protected? (Answer: No, only public or internal)
             15. What is the difference between an Assembly and an Access Modifier? (Hint: Assembly = boundary, Access Modifier = rule for crossing boundary).



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


2.What is an Assembly in .NET?
          --> An Assembly is the building block of .NET applications.
          --> It is a compiled unit that the .NET runtime (CLR – Common Language Runtime) can execute.

     Assemblies contain:
          --> Code (IL – Intermediate Language)
          --> Metadata (information about classes, methods, properties, etc.)
          --> Resources (images, strings, etc.)
        👉 In simple terms: An Assembly = Compiled Output of Your Project.


      🔹 Types of Assemblies
             1)Private Assembly
               --> Used by only one application.
              --> Stored in the application’s folder.
                Example: MyApp.dll

            2)Shared Assembly
              --> Can be used by multiple applications.
              --> Stored in the Global Assembly Cache (GAC).
              --> Must have a Strong Name (unique identity).

          3)Satellite Assembly
             --> Contains only resources (like localized strings for different languages).
             --> Used for globalization/localization.

   🔹 Assembly File Types
            --> .exe → Executable assembly (application you can run).
            --> .dll → Library assembly (cannot run directly, but used by other apps).

  🔹 Inside an Assembly
            An assembly has two main parts:
                 --> Manifest – Metadata about the assembly (version, culture, strong name).
                 --> IL Code – Compiled intermediate code (C# → IL → executed by CLR).
                       (You can inspect an assembly using the tool ILDASM (IL Disassembler).)

  🔹 Real-world Analogy
            Think of Assembly like a Book:
                 --> The chapters (code/IL) → Actual content.
                 --> The Index (metadata/manifest) → Tells what’s inside and where.
                 --> The Cover (filename: DLL/EXE) → How others identify it.
                         So, whenever you build a C# project, the final book you get is the assembly.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

OOPS:
           1) Encapsulation (Access control + data hiding)
                  What: Keep an object’s internal state private and expose controlled operations (get/set/act) via members.
                  Why: Prevent invalid states, make changes without breaking callers, and reduce coupling.
                  How in .NET: private, protected, public, internal, properties, validation logic.

                   EX:
                      public class BankAccount
                           {
                               // State is hidden
                               private decimal _balance;
                           
                               // Read-only account number (immutable after construction)
                               public string AccountNumber { get; }
                           
                               public BankAccount(string accountNumber, decimal openingBalance = 0m)
                               {
                                   if (string.IsNullOrWhiteSpace(accountNumber)) throw new ArgumentException("Account number required.");
                                   if (openingBalance < 0) throw new ArgumentOutOfRangeException(nameof(openingBalance));
                                   AccountNumber = accountNumber;
                                   _balance = openingBalance;
                               }
                           
                               public decimal GetBalance() => _balance;
                           
                               public void Deposit(decimal amount)
                               {
                                   if (amount <= 0) throw new ArgumentOutOfRangeException(nameof(amount));
                                   _balance += amount;
                               }
                           
                               public void Withdraw(decimal amount)
                               {
                                   if (amount <= 0) throw new ArgumentOutOfRangeException(nameof(amount));
                                   if (amount > _balance) throw new InvalidOperationException("Insufficient funds.");
                                   _balance -= amount;
                               }
                           }



                       2) Abstraction (Simple Definition)
                              👉 Abstraction = Showing only what is necessary, hiding the details.
                                    Abstraction means focusing on what an object does instead of how it does it. In C#, we achieve it using abstract classes and interfaces.
                                    Tool = Interfaces & Abstract Classes
                                 ✅ Real Life Example
                                                TV Remote :                                            
                                                     --> Buttons = What you can do (volume up, channel change, power on/off).                                             
                                                     --> Inside electronics = How it works (circuit board, signals, IR sensor).                              
                                                     --> You don’t need to know how signals are sent.                                             
                                                     --> You only use what is shown to you.                                   
                                                ➡️ That’s abstraction.
                                       EX:
                                         public abstract class Shape
                                             { 
                                                 // WHAT to do (every shape must have Area)
                                                 public abstract double GetArea();
                                             }
                                             
                                             public class Circle : Shape
                                             {
                                                 public double Radius { get; set; }
                                                 public Circle(double r) => Radius = r;
                                             
                                                 // HOW to do it
                                                 public override double GetArea() => Math.PI * Radius * Radius;
                                             }
                                             
                                             public class Rectangle : Shape
                                             {
                                                 public double Width { get; set; }
                                                 public double Height { get; set; }
                                             
                                                 public Rectangle(double w, double h) { Width = w; Height = h; }
                                             
                                                 public override double GetArea() => Width * Height;

                                             }

                                                   OUTPUT:
                                                            Shape s1 = new Circle(5);
                                                            Shape s2 = new Rectangle(4, 6);
                                                            
                                                            Console.WriteLine(s1.GetArea()); // Circle logic
                                                            Console.WriteLine(s2.GetArea()); // Rectangle logic




| Feature                | Abstraction                                                                                                        | Encapsulation                                                                      |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------- |
| **Definition**         | Hides *implementation details* and shows only the **essential features**.                                          | Hides *data* by restricting direct access and providing controlled access.         |
| **Focus**              | *What* an object does (behavior).                                                                                  | *How* the data of an object is protected.                                          |
| **Achieved By**        | Interfaces, Abstract classes.                                                                                      | Access modifiers (`private`, `public`, etc.) + Properties/Methods.                 |
| **Goal**               | Reduce complexity for the user.                                                                                    | Protect the integrity of data.                                                     |
| **Real-world Example** | **ATM Machine**: You only see *Withdraw, Deposit, Balance check*. Internals (database, cash dispenser) are hidden. | **ATM Card PIN**: Your data (balance, account) is hidden and protected with a PIN. |
| **In short**           | **Hiding implementation**                                                                                          | **Hiding data**                                                                    |





                🔹 1. Interface
                        ✅ What is it?
                            --> An interface is like a contract.
                            --> It defines what methods/properties a class must have, but does not provide implementation.
                            --> A class that implements an interface must provide the actual logic.
                        
                        ✅ Key Points
                              --> Only contains method signatures, properties, events (no fields, no constructors).
                              --> A class can implement multiple interfaces (C# supports multiple inheritance via interfaces).
                              --> Members are public by default.

                      🔹 Interface (Rulebook)
                              👉 Think of an interface like a rulebook 📘.                                  
                                    It only says what you must do, not how.                                    
                                    If a class agrees to follow the interface, it must implement all the rules.                                    
                                    Real-life example:                                 
                                       Remote Control Interface                                                    
                                            Rulebook says:
                                               TurnOn() must exist 
                                               TurnOff() must exist          
                                    It doesn’t care if it’s a TV, Fan, or AC. 
                                    Each device will have its own way of turning on/off.



                           EX:
                              public interface IRemote
                                       {
                                           void TurnOn();
                                           void TurnOff();
                                       }
                                       
                                       public class TV : IRemote
                                       {
                                           public void TurnOn() => Console.WriteLine("TV On");
                                           public void TurnOff() => Console.WriteLine("TV Off");
                                       }
                                       
                                       public class Fan : IRemote
                                       {
                                           public void TurnOn() => Console.WriteLine("Fan On");
                                           public void TurnOff() => Console.WriteLine("Fan Off");
                                       }


                                    OUTPUT:
                                           IRemote device = new TV();
                                           device.TurnOn();  // TV On
                                          
                                          device = new Fan();
                                          device.TurnOn();  // Fan On



                   🔹 2. Abstract Class
                          ✅ What is it?
                             -->  An abstract class is a base class that cannot be instantiated.
                             -->  It can have:
                             -->  Abstract members (no body, must be overridden in derived class).
                             -->  Concrete members (with implementation).
                             -->  Useful when you want to share common logic + enforce some methods in child classes.

                         ✅ Key Points
                             -->  Can have fields, constructors, access modifiers.
                             -->  Can provide default behavior.
                             -->  A class can inherit from only one abstract class (single inheritance).

                             🔹 Abstract Class (Template)
                                    👉 An abstract class is like a partially filled template 📑.
                                         It gives some ready-made code.
                                          But also leaves some parts blank, which child classes must fill.
                                           Real-life example:
                                             Shape Template
                                             Every shape has GetArea() (blank rule).
                                        Base class can also give a ready-made method like Display().


                         EX:
                                public abstract class Shape
                                       {
                                           // Rule: child must provide implementation
                                           public abstract double GetArea();
                                       
                                           // Ready-made code
                                           public void Display()
                                           {
                                               Console.WriteLine("This is a shape.");
                                           }
                                       }
                                       
                                       public class Circle : Shape
                                       {
                                           public double Radius { get; set; }
                                           public Circle(double r) => Radius = r;
                                       
                                           public override double GetArea() => Math.PI * Radius * Radius;
                                       }

                                        Output:
                                                 Shape s = new Circle(5);
                                                s.Display();              // "This is a shape."
                                                Console.WriteLine(s.GetArea()); // 78.5

| Feature              | Interface                                                  | Abstract Class                                                 |
| -------------------- | ---------------------------------------------------------- | -------------------------------------------------------------- |
| **Purpose**          | Define a **contract** (what to do).                        | Provide **base + partial implementation**.                     |
| **Members**          | Only methods, properties, events (no fields/constructors). | Can have fields, properties, methods, constructors.            |
| **Access Modifiers** | All members are **public** by default.                     | Can have any (public, private, protected).                     |
| **Implementation**   | No implementation (only signatures).                       | Can have both abstract and implemented methods.                |
| **Inheritance**      | A class can implement **multiple interfaces**.             | A class can inherit **only one abstract class**.               |
| **Instantiation**    | Cannot be instantiated.                                    | Cannot be instantiated.                                        |
| **Use Case**         | Use when you need a **contract across unrelated classes**. | Use when you need a **common base + enforce certain members**. |


| Feature                  | Interface (Rulebook)                | Abstract Class (Template)                 |
| ------------------------ | ----------------------------------- | ----------------------------------------- |
| **What it is**           | Only rules (no code)                | Some rules + some ready code              |
| **Fields/Variables**     | Not allowed                         | Allowed                                   |
| **Constructor**          | Not allowed                         | Allowed                                   |
| **Multiple Inheritance** | Class can implement many interfaces | Class can inherit only one abstract class |
| **Use When**             | You just need a common **contract** | You need a **base with common code**      |


          🔹 One-line Summary
                  Interface → Only “what to do” (like a rulebook).
                  Abstract class → “What to do + some ready code” (like a template).



            🔹 What is a Contract in Programming?
            👉 A contract simply means an agreement between two sides:
                     One side (the interface/abstract class) says:
                              “These methods/properties must exist.”
                     Other side (the class that implements/inherits) promises:
                              “I will provide the actual code for them.”
            So, contract = rulebook / agreement of methods and properties.



                                             






