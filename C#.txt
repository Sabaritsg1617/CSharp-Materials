 1)What is an Access Modifier?
      Access modifiers are keywords in C# that define the scope and visibility of classes, methods, variables, and other members. They control who can access them in your project

   Types:
       1. public
           --> No restriction.
           --> Accessible from anywhere (same class, other classes, other assemblies).

          EX:
                    public class Student
                     {
                        public string Name; // Accessible from anywhere
                     }

      2. private
         --> Most restrictive.
         --> Accessible only inside the same class.
         --> Default for class members (fields, methods).

              EX:
                 public class Student
                     {
                      private int age; // Only accessible inside Student class
                     }

      3.protected
           --> Accessible in the same class and in derived (child) classes.
           --> Not accessible outside if there is no inheritance.

              EX:
                  public class Person
                    {
                    protected string Address;
                    }

                   public class Student : Person
                  {
                     public void ShowAddress()
                        {
                         Console.WriteLine(Address); // OK, inherited class can access
                        }
                   }

        4. internal
             --> Accessible within the same assembly/project.
             --> Not accessible outside the assembly.
               EX:
                   internal class Teacher
                         {
                           internal void Teach()
                               {
                               Console.WriteLine("Teaching...");
                               }
                          }

        5.protected internal
                --> Combination of protected + internal.
                --> Accessible from child classes OR from the same assembly.
              EX: 
               public class Person
                  {
                    protected internal string Email;
                  }

      6. private protected (C# 7.2 and later)
             --> Combination of private + protected.
             --> Accessible only in the same assembly and only in derived classes.
             --> More restrictive than protected internal.
            EX:
              public class Person
              {
                private protected int Age;
              }

| Modifier           | Scope (Where it can be accessed)                                              | Use Case                                                                     |
| -------------------| ----------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| public             | Anywhere (same class, other classes, other assemblies)                        | For APIs, libraries, and methods meant to be used globally.                  |
| private            | Only inside the same class                                                    | For encapsulating internal details (e.g., fields, helper methods).           |
| protected          | Same class + child classes                                                    | For base class members that should be shared with derived classes.           |
| internal           | Anywhere inside the same assembly/project                                     | For code that is shared within a project but hidden from outside assemblies. |
| protected internal | Child classes (even in other assemblies) OR anywhere inside the same assembly | A mix of inheritance + internal sharing.                                     |
| private protected  | Child classes inside the **same assembly only** (introduced in C# 7.2)        | More restrictive than `protected internal`.                                  |

          🔹 Simple Summary (Easy to Remember)
            --> public → Everyone can see it.
            --> private → Only me (the class itself).
            --> protected → Me + my children (inheritance).
            --> internal → Only my family (same project/assembly).
            --> protected internal → My children (anywhere) OR my family (same assembly).
            --> private protected → My children but only if they live in the same house (same assembly).

🔹 Common Interview Questions on Access Modifiers
           ✅ Basic Questions
              1. What are access modifiers in C#?
              2. List all access modifiers available in C#.
              3. What is the default access modifier for a class? (Answer: internal)
              4. What is the default access modifier for class members? (Answer: private)

           ✅ Comparison Questions
              5. Difference between public and private.
              6. Difference between protected and internal.
              7. Difference between protected internal and private protected.
                       1)protected internal
                             Accessible by:
                                 Any class within the same assembly (internal)
                                  OR
                                Any derived (child) class in any assembly (protected)
                      Basically: Union of protected + internal

                       EX:
                           public class BaseClass
                              {
                                  protected internal int Value = 100;
                              }

                           public class Child : BaseClass
                              {
                                  public void Show()
                                  {
                                   Console.WriteLine(Value); // Accessible (inherited)
                                  }
                              }

                                 // In SAME assembly - also works without inheritance
                        public class Other
                              {
                                  public void Show()
                                     {
                                         BaseClass b = new BaseClass();
                                         Console.WriteLine(b.Value); // Accessible (same assembly)
                                     }
                              }

                     2.private protected
                           Introduced in C# 7.2
                                    Accessible by:
                                          Only derived (child) classes
                                           But within the same assembly only
                                 Basically: Intersection of protected + internal

                       ex:
                           public class BaseClass
                                {
                                     private protected int Value = 200;
                                 }

                                 public class Child : BaseClass
                                 {
                                     public void Show()
                                     {
                                         Console.WriteLine(Value); // Accessible (same assembly + inherited)
                                     }
                                 }
                                 
                                 // In SAME assembly but not a child
                                 public class Other
                                 {
                                     public void Show()
                                     {
                                         BaseClass b = new BaseClass();
                                         // Console.WriteLine(b.Value); ❌ Not Accessible
                                     }
                                 }



              8. Which access modifiers are allowed at class level? (Answer: public, internal)

          ✅ Scenario-based Questions
             9. If a class is marked internal, can it be accessed from another assembly? (Answer: No)
            10. Can a protected member be accessed without inheritance? (Answer: No)
            11. Which access modifier will you use for utility/helper methods inside a class? (Answer: private)
            12. Which access modifier will you use for framework/library classes meant to be reused by other projects? (Answer: public)

         ✅ Advanced Questions
             13. Why was private protected introduced in C# 7.2?
                            --> Before C# 7.2, we had protected internal, but it was too permissive.
                            --> Any class in the same assembly could access it (even if not derived).                               
                            --> Any child class in other assemblies could also access it.                                 
                            --> Developers wanted a stricter option:                                
                            --> Accessible only to derived classes                            
                            --> And only inside the same assembly.                 
                            --> So Microsoft introduced private protected in C# 7.2.

               👉 Short Interview Answer:
                           private protected was introduced to give developers finer control — it restricts access to only derived classes within the same assembly, 
                           unlike protected internal which is more open.
             14. Can a top-level class be declared private or protected? (Answer: No, only public or internal)
             15. What is the difference between an Assembly and an Access Modifier? (Hint: Assembly = boundary, Access Modifier = rule for crossing boundary).



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


2.What is an Assembly in .NET?
          --> An Assembly is the building block of .NET applications.
          --> It is a compiled unit that the .NET runtime (CLR – Common Language Runtime) can execute.

     Assemblies contain:
          --> Code (IL – Intermediate Language)
          --> Metadata (information about classes, methods, properties, etc.)
          --> Resources (images, strings, etc.)
        👉 In simple terms: An Assembly = Compiled Output of Your Project.


      🔹 Types of Assemblies
             1)Private Assembly
               --> Used by only one application.
              --> Stored in the application’s folder.
                Example: MyApp.dll

            2)Shared Assembly
              --> Can be used by multiple applications.
              --> Stored in the Global Assembly Cache (GAC).
              --> Must have a Strong Name (unique identity).

          3)Satellite Assembly
             --> Contains only resources (like localized strings for different languages).
             --> Used for globalization/localization.

   🔹 Assembly File Types
            --> .exe → Executable assembly (application you can run).
            --> .dll → Library assembly (cannot run directly, but used by other apps).

  🔹 Inside an Assembly
            An assembly has two main parts:
                 --> Manifest – Metadata about the assembly (version, culture, strong name).
                 --> IL Code – Compiled intermediate code (C# → IL → executed by CLR).
                       (You can inspect an assembly using the tool ILDASM (IL Disassembler).)

  🔹 Real-world Analogy
            Think of Assembly like a Book:
                 --> The chapters (code/IL) → Actual content.
                 --> The Index (metadata/manifest) → Tells what’s inside and where.
                 --> The Cover (filename: DLL/EXE) → How others identify it.
                         So, whenever you build a C# project, the final book you get is the assembly.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

OOPS:
           1) Encapsulation (Access control + data hiding)
                  What: Keep an object’s internal state private and expose controlled operations (get/set/act) via members.
                  Why: Prevent invalid states, make changes without breaking callers, and reduce coupling.
                  How in .NET: private, protected, public, internal, properties, validation logic.

                   EX:
                      public class BankAccount
                           {
                               // State is hidden
                               private decimal _balance;
                           
                               // Read-only account number (immutable after construction)
                               public string AccountNumber { get; }
                           
                               public BankAccount(string accountNumber, decimal openingBalance = 0m)
                               {
                                   if (string.IsNullOrWhiteSpace(accountNumber)) throw new ArgumentException("Account number required.");
                                   if (openingBalance < 0) throw new ArgumentOutOfRangeException(nameof(openingBalance));
                                   AccountNumber = accountNumber;
                                   _balance = openingBalance;
                               }
                           
                               public decimal GetBalance() => _balance;
                           
                               public void Deposit(decimal amount)
                               {
                                   if (amount <= 0) throw new ArgumentOutOfRangeException(nameof(amount));
                                   _balance += amount;
                               }
                           
                               public void Withdraw(decimal amount)
                               {
                                   if (amount <= 0) throw new ArgumentOutOfRangeException(nameof(amount));
                                   if (amount > _balance) throw new InvalidOperationException("Insufficient funds.");
                                   _balance -= amount;
                               }
                           }



                       2) Abstraction (Simple Definition)
                              👉 Abstraction = Showing only what is necessary, hiding the details.
                                    Abstraction means focusing on what an object does instead of how it does it. In C#, we achieve it using abstract classes and interfaces.
                                    Tool = Interfaces & Abstract Classes
                                 ✅ Real Life Example
                                                TV Remote :                                            
                                                     --> Buttons = What you can do (volume up, channel change, power on/off).                                             
                                                     --> Inside electronics = How it works (circuit board, signals, IR sensor).                              
                                                     --> You don’t need to know how signals are sent.                                             
                                                     --> You only use what is shown to you.                                   
                                                ➡️ That’s abstraction.
                                       EX:
                                         public abstract class Shape
                                             { 
                                                 // WHAT to do (every shape must have Area)
                                                 public abstract double GetArea();
                                             }
                                             
                                             public class Circle : Shape
                                             {
                                                 public double Radius { get; set; }
                                                 public Circle(double r) => Radius = r;
                                             
                                                 // HOW to do it
                                                 public override double GetArea() => Math.PI * Radius * Radius;
                                             }
                                             
                                             public class Rectangle : Shape
                                             {
                                                 public double Width { get; set; }
                                                 public double Height { get; set; }
                                             
                                                 public Rectangle(double w, double h) { Width = w; Height = h; }
                                             
                                                 public override double GetArea() => Width * Height;

                                             }

                                                   OUTPUT:
                                                            Shape s1 = new Circle(5);
                                                            Shape s2 = new Rectangle(4, 6);
                                                            
                                                            Console.WriteLine(s1.GetArea()); // Circle logic
                                                            Console.WriteLine(s2.GetArea()); // Rectangle logic




| Feature                | Abstraction                                                                                                        | Encapsulation                                                                      |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------- |
| **Definition**         | Hides *implementation details* and shows only the **essential features**.                                          | Hides *data* by restricting direct access and providing controlled access.         |
| **Focus**              | *What* an object does (behavior).                                                                                  | *How* the data of an object is protected.                                          |
| **Achieved By**        | Interfaces, Abstract classes.                                                                                      | Access modifiers (`private`, `public`, etc.) + Properties/Methods.                 |
| **Goal**               | Reduce complexity for the user.                                                                                    | Protect the integrity of data.                                                     |
| **Real-world Example** | **ATM Machine**: You only see *Withdraw, Deposit, Balance check*. Internals (database, cash dispenser) are hidden. | **ATM Card PIN**: Your data (balance, account) is hidden and protected with a PIN. |
| **In short**           | **Hiding implementation**                                                                                          | **Hiding data**                                                                    |





                🔹 1. Interface
                        ✅ What is it?
                            --> An interface is like a contract.
                            --> It defines what methods/properties a class must have, but does not provide implementation.
                            --> A class that implements an interface must provide the actual logic.
                        
                        ✅ Key Points
                              --> Only contains method signatures, properties, events (no fields, no constructors).
                              --> A class can implement multiple interfaces (C# supports multiple inheritance via interfaces).
                              --> Members are public by default.

                      🔹 Interface (Rulebook)
                              👉 Think of an interface like a rulebook 📘.                                  
                                    It only says what you must do, not how.                                    
                                    If a class agrees to follow the interface, it must implement all the rules.                                    
                                    Real-life example:                                 
                                       Remote Control Interface                                                    
                                            Rulebook says:
                                               TurnOn() must exist 
                                               TurnOff() must exist          
                                    It doesn’t care if it’s a TV, Fan, or AC. 
                                    Each device will have its own way of turning on/off.



                           EX:
                              public interface IRemote
                                       {
                                           void TurnOn();
                                           void TurnOff();
                                       }
                                       
                                       public class TV : IRemote
                                       {
                                           public void TurnOn() => Console.WriteLine("TV On");
                                           public void TurnOff() => Console.WriteLine("TV Off");
                                       }
                                       
                                       public class Fan : IRemote
                                       {
                                           public void TurnOn() => Console.WriteLine("Fan On");
                                           public void TurnOff() => Console.WriteLine("Fan Off");
                                       }


                                    OUTPUT:
                                           IRemote device = new TV();
                                           device.TurnOn();  // TV On
                                          
                                          device = new Fan();
                                          device.TurnOn();  // Fan On



                   🔹 2. Abstract Class
                          ✅ What is it?
                             -->  An abstract class is a base class that cannot be instantiated.
                             -->  It can have:
                             -->  Abstract members (no body, must be overridden in derived class).
                             -->  Concrete members (with implementation).
                             -->  Useful when you want to share common logic + enforce some methods in child classes.

                         ✅ Key Points
                             -->  Can have fields, constructors, access modifiers.
                             -->  Can provide default behavior.
                             -->  A class can inherit from only one abstract class (single inheritance).

                             🔹 Abstract Class (Template)
                                    👉 An abstract class is like a partially filled template 📑.
                                         It gives some ready-made code.
                                          But also leaves some parts blank, which child classes must fill.
                                           Real-life example:
                                             Shape Template
                                             Every shape has GetArea() (blank rule).
                                        Base class can also give a ready-made method like Display().


                         EX:
                                public abstract class Shape
                                       {
                                           // Rule: child must provide implementation
                                           public abstract double GetArea();
                                       
                                           // Ready-made code
                                           public void Display()
                                           {
                                               Console.WriteLine("This is a shape.");
                                           }
                                       }
                                       
                                       public class Circle : Shape
                                       {
                                           public double Radius { get; set; }
                                           public Circle(double r) => Radius = r;
                                       
                                           public override double GetArea() => Math.PI * Radius * Radius;
                                       }

                                        Output:
                                                 Shape s = new Circle(5);
                                                s.Display();              // "This is a shape."
                                                Console.WriteLine(s.GetArea()); // 78.5

| Feature              | Interface                                                  | Abstract Class                                                 |
| -------------------- | ---------------------------------------------------------- | -------------------------------------------------------------- |
| **Purpose**          | Define a **contract** (what to do).                        | Provide **base + partial implementation**.                     |
| **Members**          | Only methods, properties, events (no fields/constructors). | Can have fields, properties, methods, constructors.            |
| **Access Modifiers** | All members are **public** by default.                     | Can have any (public, private, protected).                     |
| **Implementation**   | No implementation (only signatures).                       | Can have both abstract and implemented methods.                |
| **Inheritance**      | A class can implement **multiple interfaces**.             | A class can inherit **only one abstract class**.               |
| **Instantiation**    | Cannot be instantiated.                                    | Cannot be instantiated.                                        |
| **Use Case**         | Use when you need a **contract across unrelated classes**. | Use when you need a **common base + enforce certain members**. |


| Feature                  | Interface (Rulebook)                | Abstract Class (Template)                 |
| ------------------------ | ----------------------------------- | ----------------------------------------- |
| **What it is**           | Only rules (no code)                | Some rules + some ready code              |
| **Fields/Variables**     | Not allowed                         | Allowed                                   |
| **Constructor**          | Not allowed                         | Allowed                                   |
| **Multiple Inheritance** | Class can implement many interfaces | Class can inherit only one abstract class |
| **Use When**             | You just need a common **contract** | You need a **base with common code**      |


          🔹 One-line Summary
                  Interface → Only “what to do” (like a rulebook).
                  Abstract class → “What to do + some ready code” (like a template).



            🔹 What is a Contract in Programming?
                   👉 A contract simply means an agreement between two sides:
                            One side (the interface/abstract class) says:
                                     “These methods/properties must exist.”
                            Other side (the class that implements/inherits) promises:
                                     “I will provide the actual code for them.”
                   So, contract = rulebook / agreement of methods and properties.
       
                   --> Contract = an agreement that defines what methods/properties must exist in a class.


   3) Inheritance:
        --> Inheritance = creating a new class from an existing class, reusing its members.
        --> Child class (derived) inherits properties, fields, and methods of the parent class (base).

         🔹 Why Use Inheritance?
              -->   Reuse existing code (avoid duplication).
              -->   Add new features to existing behavior.
              -->   Enable Polymorphism (runtime flexibility).


| Concept               | C# Keyword        | VB.NET Keyword             |
| --------------------- | ----------------- | -------------------------- |
| Inheritance (extends) | `:`               | `Inherits`                 |
| Base class            | `base`            | `MyBase`                   |
| Virtual method        | `virtual`         | `Overridable`              |
| Override method       | `override`        | `Overrides`                |
| Prevent inheritance   | `sealed`          | `NotInheritable`           |
| Prevent overriding    | `sealed override` | `NotOverridable Overrides` |
| Abstract method       | `abstract`        | `MustOverride`             |


EX:
       // Base class (Parent)
       public class Animal
       {
           public void Eat() => Console.WriteLine("Animal is eating");
       
           public virtual void Speak() => Console.WriteLine("Animal makes a sound");
       }
       
       // Derived class (Child)
       public class Dog : Animal
       {
           public void Run() => Console.WriteLine("Dog is running");
       
           public override void Speak() => Console.WriteLine("Dog barks");
       }
       
       // Derived class (Child)
       public class Cat : Animal
       {
           public override void Speak() => Console.WriteLine("Cat meows");
       }


🔹 Types of Inheritance in .NET
     Single Inheritance
        One base class → one derived class.
        ✅ Supported.

               Vehicle
                 │
                 ▼
                Car

            public class Vehicle
              {
                  public void Drive() => Console.WriteLine("Driving...");
              }
              
              public class Car : Vehicle
              {
                  public void Honk() => Console.WriteLine("Car Honks!");
              }

     
     Multilevel Inheritance
        A base class → derived class → another derived class.
        ✅ Supported.
                        
                        Animal
                           │
                           ▼
                         Mammal
                           │
                           ▼
                          Dog


          public class Animal
              {
                  public void Eat() => Console.WriteLine("Eating...");
              }
              
              public class Mammal : Animal
              {
                  public void Walk() => Console.WriteLine("Walking...");
              }
              
              public class Dog : Mammal
              {
                  public void Bark() => Console.WriteLine("Barking...");
              }

     
     Hierarchical Inheritance
        One base class → multiple derived classes.
        ✅ Supported.
                 Shape
                /   |   \
             Circle Rect  Triangle

            public class Shape
              {
                  public virtual void Draw() => Console.WriteLine("Drawing Shape...");
              }
              
              public class Circle : Shape
              {
                  public override void Draw() => Console.WriteLine("Drawing Circle");
              }
              
              public class Rectangle : Shape
              {
                  public override void Draw() => Console.WriteLine("Drawing Rectangle");
              }

     
     Multiple Inheritance (two parents → one child)
        👉 A class inherits from more than one base class.
        ❌ Not supported with classes (to avoid diamond problem).
        ✅ Achieved using Interfaces.

                    Car       Airplane
                        \       /
                         \     /
                        FlyingCar


             public interface ICar
               {
                   void Drive();
               }
               
               public interface IAirplane
               {
                   void Fly();
               }
               
               public class FlyingCar : ICar, IAirplane
               {
                   public void Drive() => Console.WriteLine("Driving...");
                   public void Fly() => Console.WriteLine("Flying...");
               }


        5. Hybrid Inheritance (Combination)
             👉 Combination of more than one type (hierarchical + multiple).
              ❌ Not supported with classes in C#.
               ✅ Can be achieved with interfaces.


              🔹 Interview One-Liners
                      Single: One parent → one child.
                      Multilevel: Parent → child → grandchild.
                      Hierarchical: One parent → many children.
                      Multiple: One child → many parents (not supported with classes).
                      Hybrid: Combination of multiple types (possible only via interfaces in C#).




            4)Polymorphism
                  👉 Polymorphism = “Many Forms.”
                      Same method name → different behaviors depending on the object.
                      It allows us to perform a single action in different ways.


                🔹 Types of Polymorphism in .NET
                   --> Compile-time Polymorphism (Static)
                         Achieved using Method Overloading and Operator Overloading.
                         Decided at compile time.
                            public class Calculator
                                 {
                                     // Method Overloading
                                     public int Add(int a, int b) => a + b;
                                     public double Add(double a, double b) => a + b;
                                 }
                                 
                                 class Program
                                 {
                                     static void Main()
                                     {
                                         Calculator c = new Calculator();
                                         Console.WriteLine(c.Add(5, 10));       // Calls int Add
                                         Console.WriteLine(c.Add(5.5, 3.3));    // Calls double Add
                                     }
                                 }


                    -->  Runtime Polymorphism (Dynamic)
                           Achieved using Method Overriding (with virtual, override, abstract).
                           Decided at runtime.
                              public class Animal
                                 {
                                     public virtual void Speak()
                                     {
                                         Console.WriteLine("Animal makes a sound");
                                     }
                                 }
                                 
                                 public class Dog : Animal
                                 {
                                     public override void Speak()
                                     {
                                         Console.WriteLine("Dog barks");
                                     }
                                 }
                                 
                                 public class Cat : Animal
                                 {
                                     public override void Speak()
                                     {
                                         Console.WriteLine("Cat meows");
                                     }
                                 }
                                 
                                 class Program
                                 {
                                     static void Main()
                                     {
                                         Animal a;
                                 
                                         a = new Dog();
                                         a.Speak();   // Output: Dog barks
                                 
                                         a = new Cat();
                                         a.Speak();   // Output: Cat meows
                                     }
                                 }


                        🔹 Interview One-Liners
                                Polymorphism = same method name but different behaviors.
                          Two types:
                                Compile-time → Method Overloading, Operator Overloading.
                                Runtime → Method Overriding (virtual, override).
                          Enables flexibility and reusability.






🔹 Differences Between OOP Concepts
 | Concept     | What it is                                                           | How it is done in C#                                                | Example                                                                                       
| ------------ | ------------------------------------------------------------------   | --------------------------------------------------------------------| ----------------------------------------------------------
| Encapsulation| Hiding **data** and controlling access                               | Using **access modifiers** (`private`, `public`, `protected`, etc.) | Private `balance` field in `BankAccount` accessible only                                                                                                                                                                       via `Deposit()`/`Withdraw()` methods                    |
| Abstraction  | Hiding **implementation details**, showing only essentials           | Using **abstract classes** and **interfaces**                       | `IShape.GetArea()` (interface) tells *what* to do,                                                                                                                                                                               classes like `Circle` implement *how*                 |
| Inheritance  | Reusing parent class features in child class (**is-a** relationship) | Using `:` in C# (`Inherits` in VB.NET)                              | `Dog : Animal` (Dog is an Animal)                         |                                                 
| Polymorphism | Same method name → different behaviors                               | **Compile-time**: Overloading, **Runtime**: Overriding              | `Speak()` behaves differently in `Dog`, `Cat`             |    




🔹 Quick One-Liners
      Encapsulation → Hides Data → Access Modifiers.
      Abstraction → Hides Implementation → Interfaces/Abstract Classes.
      Inheritance → Reuses Code → is-a relationship.
      Polymorphism → Same method, different behaviors → Overloading/Overriding.


🔹 Common Interview Questions & Answers
     1. What is Encapsulation?
             Answer: Encapsulation is the process of hiding data inside a class and exposing it through controlled access (methods/properties). In .NET, it is implemented using access modifiers like private, public, 
             protected.
             👉 Example: private balance field in a BankAccount class accessed only via Deposit() and Withdraw() methods.
     
     2. What is Abstraction?
            Answer: Abstraction is hiding implementation details and exposing only the essential functionality. In .NET, it is achieved using abstract classes and interfaces.
            👉 Example: IShape defines GetArea() but does not say how. Circle and Rectangle provide their own implementation.
     
     3. What is Inheritance?
            Answer: Inheritance allows one class (child) to acquire the fields and methods of another class (parent). This creates an is-a relationship. In .NET, inheritance is implemented using : (C#) or Inherits 
            (VB.NET).
           👉 Example: Dog : Animal → Dog inherits methods from Animal.
     
     4. What is Polymorphism?
             Answer: Polymorphism means “many forms.” It allows the same method to behave differently in different contexts.
             Compile-time polymorphism: Achieved via method overloading.
             Runtime polymorphism: Achieved via method overriding using virtual and override.
             👉 Example: Speak() behaves differently for Dog (barks) and Cat (meows).
     
     5. Difference Between Abstraction and Encapsulation?
           Answer:
               Abstraction → Hides implementation (focus on what to do).
               Encapsulation → Hides data (focus on how to protect data).
     
     6. Why multiple inheritance is not supported in C#?
           Answer: To avoid the diamond problem (ambiguity when two base classes have same method). Instead, multiple inheritance is achieved using interfaces.
     
     7. Difference between Compile-time and Runtime Polymorphism?
           Answer:
                 Compile-time Polymorphism → Method Overloading (resolved at compile time).
                 Runtime Polymorphism → Method Overriding (resolved at runtime).



 🔹 Other Important OOP Concepts in .NET
             1. Class and Object
             Class = blueprint/template.
             Object = real instance of a class.
             👉 Example: Car is a class, myCar is an object of Car.
             
             Interview Question:
             Q: Difference between class and object?
             A: Class is a definition, object is an instance created from the class.
             
             2. Constructor & Destructor
             Constructor → Special method used to initialize an object (same name as class).
             Destructor → Used to clean up resources (in C#, rarely used because Garbage Collector handles memory).
             
             Interview Question:
             Q: Can we overload constructors?
             A: Yes (called constructor overloading).
             
             3. Static vs Instance Members
             Static → Belongs to the class, shared by all objects.
             Instance → Belongs to a particular object.
             
             Interview Question:
             Q: Difference between static and instance members?
             A: Static is shared, instance is per object.
             
             4. Sealed Class & Method
             sealed class → cannot be inherited.
             sealed method → cannot be overridden further.
             
             Interview Question:
             Q: Why use sealed?
             A: To prevent inheritance and improve security/performance.
             
             5. Abstract Class vs Interface
             👉 Already covered, but very common interview question.
             
             6. Virtual, Override, New Keywords
             virtual → method in base class can be overridden.
             override → provides new implementation in derived class.
             new → hides base class method (not polymorphism).
             
             Interview Question:
             Q: Difference between override and new keyword?
             A: override replaces base method (polymorphism), new hides base method (no polymorphism).
             
             7. Overloading vs Overriding
             Overloading → same method name, different parameter list. (Compile-time polymorphism).
             Overriding → same method name, same signature, but in derived class. (Runtime polymorphism).
             
             Interview Question:
             Q: Can we overload static methods?
             A: Yes.
             
             Q: Can we override static methods?
             A: No.
             
             8. Association, Aggregation, Composition
             Association → simple relationship (Teacher teaches Student).
             Aggregation → “Has-a” weak relationship (Library has Books, books can exist without library).
             Composition → “Has-a” strong relationship (Car has Engine, engine cannot exist without car).
             
             Interview Question:
             Q: Difference between Aggregation and Composition?
             A: Aggregation = weak dependency, Composition = strong dependency.
             
             9. Access Modifiers (already covered)
             Very common interview question.
             Public, Private, Protected, Internal, Protected Internal, Private Protected.
             
             10. Interfaces and Multiple Inheritance
             Since multiple inheritance is not supported in C#, interfaces are often used.
             Very common question: Why use interfaces?

🔹 Common Advanced OOP Interview Questions
      1)What is the difference between Abstraction and Encapsulation?
      2)Why multiple inheritance is not supported in C#?
      3)What is the difference between Interface and Abstract Class?
      4)Can constructors be inherited? (No)
      5)Can we create object of abstract class? (No, but we can use reference of it).
      6)What is method hiding (new keyword)?
      7)Difference between early binding (compile-time polymorphism) and late binding (runtime polymorphism)?
      8)What is the difference between Association, Aggregation, and Composition?
      9)Can static methods be overridden? (No, only hidden).
      10)What is difference between base and this keyword?

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

What is a thread?
--> A single sequence of execution within a process; one “worker” that executes code.
       Imagine a restaurant with many cooks (threads). Each cook can do one job at a time.
       Creating a new cook is expensive (time + memory), so we reuse cooks from a thread pool.
       In an app, threads run your code. If a thread is busy waiting (blocked), it cannot do other work.


2) Synchronous (blocking) vs Asynchronous (non-blocking) — the core idea
       Synchronous (blocking):
       The worker starts a job and waits until it finishes, doing nothing else.
       Example: cook starts boiling water and stands there watching until it boils — useless waiting.
                   // BLOCKING call - thread waits here
                   var students = db.Students.ToList(); // blocks thread until DB returns
                   return View(students);


       Asynchronous (non-blocking):
       The worker starts the job, says “I’ll be notified when it’s ready,” and moves on to other work.
       Example: cook starts water, leaves it on a timer, prepares other dishes. When the timer rings, cook returns.
                      public async Task<ActionResult> Index()
                      {
                          // Start DB query and yield the thread while DB works.
                          var students = await db.Students.ToListAsync();
                          return View(students);
                      }
       
       Key point: Async is about not blocking the worker/thread while waiting for slow operations (usually I/O like DB, network, disk).


4) Task, Task<T>, async, await — what each means
      Task — represents an asynchronous operation with no result (like Task in C#).
      Task<T> — async operation that produces a result of type T (e.g., Task<List<Student>>).
      async — a modifier on a method telling the compiler this method contains await and will be transformed into a state machine.
      await — tells the runtime: “start this async work; return control to caller until it finishes; when it finishes, resume here.”
      
      Important: await does not create a new thread by itself. It frees the current thread while the awaited operation (usually I/O) is in progress.

5) What await does (very short)
       The compiler turns the method into a lightweight state machine.
       When you await an incomplete Task, the current method returns (a Task object) to its caller and the thread is free.
       When the awaited Task completes, the remainder of the method runs (a continuation), usually on a thread from the thread pool.

Step-by-step: what happens when ASP.NET handles your Index action
      public async Task<ActionResult> Index()
   {
       return View(await db.Students.ToListAsync());
   }


   Step flow:
            Request arrives — ASP.NET assigns a thread from the thread pool to handle the HTTP request.
            That thread calls Index(). Because Index is async, it will return a Task<ActionResult> immediately when it hits an await on an incomplete Task.
            db.Students.ToListAsync() is started — this is an I/O operation (DB). The call is started, and the code awaits it. The await causes the method to yield: the thread is released back to the pool to serve other requests.
            The DB works (I/O) in the background (no app thread is tied up waiting).
            When the DB returns results, a continuation is scheduled: the remainder of Index() runs on a thread (usually from the pool).
            View(students) executes and returns a ViewResult which completes the Task<ActionResult>. ASP.NET sends the HTTP response.

            Why this is good: while waiting on DB, your server can handle other incoming requests because threads are not blocked.


Small FAQ / Interview bullets

Q: What does async do?
A: Marks a method to allow await inside and to return a Task/Task<T>. Compiler makes a state machine.

Q: What does await do?
A: Pauses method execution until the awaited Task completes, but does not block the thread.

Q: Task vs Task<T>?
A: Task = no result; Task<T> = produces T.

Q: Why use async in web apps?
A: To free threads during I/O waits so the server can handle more requests (better scalability).

Q: Can async make code run faster?
A: It can increase concurrency and throughput for I/O-heavy apps, but doesn’t make CPU work faster.

Q: What is thread pool?
A: A pool of reusable threads used to service work items; avoids cost of creating/destroying threads.

Q: What is deadlock with async?
A: Happens when code blocks waiting for an async Task to complete (using .Result) while the awaited continuation needs the blocked thread’s context. Avoid blocking — use await.



IActionResult and Action Result:
            When you write a controller action in ASP.NET MVC / ASP.NET Core, the method has to return something that tells the framework what to do with the HTTP response.
            That “something” is called a Result (example: return a view, return JSON, redirect to another page, return status code, etc.).

2) ActionResult (Class)
        Type: It’s a class in Microsoft.AspNetCore.Mvc.
        Purpose: It is the base class for all built-in results like ViewResult, JsonResult, RedirectResult, ContentResult, etc.
        Usage: If your method always returns one of these result types, you can declare it as ActionResult.

            public ActionResult Index()
              {
                  return View(); // returns a ViewResult (subclass of ActionResult)
              }
              
              public ActionResult GetMessage()
              {
                  return Content("Hello World"); // returns ContentResult
              }

IActionResult (Interface)
      Type: It’s an interface in Microsoft.AspNetCore.Mvc.
      Purpose: Any class that can be used as an action result implements this interface.
      Usage: If your method might return different kinds of results, IActionResult gives you more flexibility because it’s an abstraction (interface).

                public IActionResult GetStudent(int id)
              {
                  if (id == 0)
                      return NotFound(); // returns NotFoundResult
                  else
                      return Json(new { Id = id, Name = "John" }); // returns JsonResult
              }

ActionResult<T> (ASP.NET Core Feature)
        In ASP.NET Core 2.1+, Microsoft introduced ActionResult<T>.
        This lets you return either a strongly typed object (T) or a traditional ActionResult.
        Helps combine Web API style responses (returning data objects) with MVC style results

               public ActionResult<Student> GetStudent(int id)
               {
                   if (id == 0)
                       return NotFound(); // ActionResult
                   else
                       return new Student { Id = id, Name = "John" }; // T (Student object)
               }

Difference Table

| Feature        | `ActionResult` (Class)                  | `IActionResult` (Interface)                  |
| -------------- | --------------------------------------- | -------------------------------------------- |
| Type           | Class                                   | Interface                                    |
| Purpose        | Base class for all results              | Contract that results must follow            |
| Flexibility    | Limited (must return subclasses)        | More flexible (any implementing class)       |
| Common Usage   | MVC controllers returning views/content | APIs or controllers returning mixed results  |
| Example Return | `ViewResult`, `JsonResult`              | `NotFoundResult`, `JsonResult`, `ViewResult` |


Interview-ready Q&A

Q1: What is the difference between ActionResult and IActionResult?
👉 ActionResult is a class (base for results), while IActionResult is an interface implemented by result classes. IActionResult is more flexible since any class implementing it can be returned.

Q2: When should you use IActionResult?
👉 Use it when your action can return different result types (e.g., NotFound OR Json).

Q3: When should you use ActionResult?
👉 Use it when your action will always return one of the standard result types (e.g., always returning a View).

Q4: What is ActionResult<T> and why was it introduced?
👉 It allows you to return either a typed object (T) or an ActionResult, combining Web API style and MVC style in one. It improves readability and flexibility in APIs.


✅ So in short:
       ActionResult = Base class (for ViewResult, JsonResult, etc.)
       IActionResult = Interface (flexible, multiple return types allowed)
       ActionResult<T> = Hybrid (typed response + traditional results)




                                             






